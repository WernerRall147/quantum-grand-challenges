FILE: 1507.08852v1.pdf
PAGES: 9
TITLE_GUESS: Realization of a scalable Shor algorithm
ABSTRACT_EXTRACT:
[not found]
FIRST_PAGES_TEXT:
Realization of a scalable Shor algorithm T. Monz, 1 D. Nigg, 1 E. A. Martinez, 1 M. F. Brandl, 1 P. Schindler,1 R. Rines, 2 S. X. Wang, 2 I. L. Chuang, 2 and R. Blatt 1, 3 1Institut f¨ ur Experimentalphysik, Universit¨ at Innsbruck, Technikerstr. 25, A-6020 Innsbruck, Austria 2Center for Ultracold Atoms, Massachusetts Institute of Technology, 77 Massachusetts Ave, Cambridge, MA, USA 3Institut f¨ ur Quantenoptik und Quanteninformation, ¨Osterreichische Akademie der Wissenschaften, Otto-Hittmair-Platz 1, A-6020 Innsbruck, Austria (Dated: August 3, 2015) Quantum computers are able to outperform classical algorithms. This was long recognized by the visionary Richard Feynman who pointed out in the 1980s that quantum mechanical problems were better solved with quantum machines. It was only in 1994 that Peter Shor came up with an algorithm that is able to calculate the prime factors of a large number vastly more eﬃciently than known possible with a classical computer [1]. This paradigmatic algorithm stimulated the ﬂourishing research in quantum information processing and the quest for an actual implementation of a quantum computer. Over the last ﬁfteen years, using skillful optimizations, several instances of a Shor algorithm have been implemented on various platforms and clearly proved the feasibility of quantum factoring [2–7]. For general scalability, though, a diﬀerent approach has to be pursued [8]. Here, we report the realization of a fully scalable Shor algorithm as proposed by Kitaev [9]. For this, we demonstrate factoring the number ﬁfteen by eﬀectively employing and controlling seven qubits and four “cache-qubits”, together with the implementation of generalized arithmetic operations, known as modular multipliers. The scalable algorithm has been realized with an ion-trap quantum computer exhibiting success probabilities in excess of 90%. PACS numbers: 03.67.Lx, 37.10.Ty, 32.80.Qk Shor’s algorithm for factoring integers [1] is one of the examples where a quantum computer (QC) outperforms the most eﬃcient known classical algorithms. Experi- mentally, its implementation is highly demanding as it requires both a suﬃciently large quantum register and high-ﬁdelity control. Clearly, such challenging require- ments raise the question whether optimizations and ex- perimental shortcuts are possible. While optimizations, especially system-speciﬁc or architectural, certainly are possible, for a demonstration of Shor’s algorithm to be scalable special care has to be taken not to oversimplify the implementation - for instance by employing knowl- edge about the solution prior to the actual experimental implementation - as pointed out in Ref. 8. In order to elucidate the general task at hand, we ﬁrst explain and exemplify Shor’s algorithm for factoring the number 15 in a (quantum) circuit model. Subsequently, we show how this circuit model is translated for and im- plemented with an ion-trap quantum computer. How does Shor’s algorithm work? Here is a classi- cal recipe to ﬁnd the factors of a large number. As an example, assume the number we want to factor is N = 15. Then pick a random number a∈ [2,N − 1] (which we call the base in the following), say a = 7. Check if the greatest common divisor gcd( a,N ) = 1, otherwise a factor is already determined. This is the case fora ={3, 5, 6, 9, 10, 12}. Next, calculate the modu- lar exponentiations ax mod N for x = 0, 1, 2... and ﬁnd its period r: the ﬁrst x >0 such that ax mod N = 1. Given the period r, ﬁnding the factors requires calcu- lating the greatest common divisors of ar/2± 1 and N, which is classically eﬃciently possible - for instance us- ing Euclid’s algorithm. For our example (N = 15,a = 7) the modular exponentiation yields 1, 7, 4, 13, 1, ..., which has period 4. The greatest common divisor of ar/2± 1 = 7 4/2± 1 = {48, 50} and N = 15 are {3, 5}, the non-trivial factors of N. For the chosen example N = 15, the cases a ={4, 11, 14} have periodicity r = 2 and would only require a single multiplication step ( a2 mod N = 1), which is considered an “easy” case [8]. Note that the periodicity for a chosen a can not be predicted. How can this recipe be implemented in a QC? A QC also has to calculate ax mod N in a computational reg- ister for x = 0, 1, 2... and then extract r. However, using the quantum Fourier-transform (QFT), this can be done with high probability in a single step (compared to r steps classically). Here, x is stored in a quantum reg- ister consisting of k qubits, or period-register, which is in a superposition of 0 to 2 k− 1. The superposition in the period-register on its own does not provide a speedup compared to a classical computer. Measuring the period- register would collapse the state and only return a sin- gle value, say x1, and the corresponding answer to ax1 mod N in the computational register. However, if the QFT is applied to the period-register, the period of ax mod N can be extracted from O(1) measurements. What are the requirements and challenges to imple- ment Shor’s algorithm? First, we focus on the period- register, to subsequently address modular exponentia- tion in the computational register. Factoring N, an n = ⌈log2(N)⌉-bit number requires a minimum of n qubits in the computational register (to store the re- arXiv:1507.08852v1 [quant-ph] 31 Jul 2015 2 H H 90 H 90 45H H H H H 90 H 90 45H H H H H 90 H 90 45H H H FIG. 1: Circuit diagram of Shor’s algorithm for factoring 15 based on Kitaev’s approach for: a) a generic base a; and the speciﬁc circuit representations for the modular multipliers; b) The actual implementation for factoring 15 to base 11, optimised for the single input state it is subject to; c) Kitaev’s approach to Shor’s algorithm for the bases {2,7,8,13}: the optimised map of the ﬁrst multiplier is identical in all 4 cases, the last multiplier is implemented with full modular multipliers as depicted in d); d) Circuit diagrams of the modular multipliers of the form a mod N for bases a= {2,7,8,11,13}. sults of ax mod N) and generally about 2 n qubits in the period-register [10]. Thus even a seemingly simple example such as factoring 15 (an n = 4 -bit number), would require 3n = 12 qubits when implemented in this straightforward way. These qubits then would have to be manipulated with high ﬁdelity gates. Given the current state-of-the-art control over quantum systems [11], such an approach likely yields an unsatisfying performance. However, a full quantum implementation of this part of the algorithm is not really necessary. In Ref. 9 Ki- taev notes that, if only the classical information of the QFT (such as the period r) is of interest, 2n qubits sub- ject to a QFT can be replaced by a single qubit. This approach, however, requires qubit-recycling (speciﬁcally: in-sequence single-qubit readout and state reinitializa- tion) paired with feed-forward to compensate for the re- duced system size. In the following, Kitaev’s QFT will be referred to as KQFT(M). It replaces a QFT acting on M qubits with a semiclassical QFT acting repeatedly on a single qubit. Similar applications of Kitaev’s approach to a semiclas- sical QFT in quantum algorithms have been investigated in Refs. [12–14]. For the implementation of Shor’s algo- rithm, Kitaev’s approach provides a reduction from the previous n computational qubits and 2n QFT qubits (in total 3n qubits) to only n computational-qubits and 1 KQFT(2n) qubit (in total n + 1 qubits). A notably more challenging aspect than the QFT, and the second key-ingredient of Shor’s algorithm, is the mod- ular exponentiation, which admits these general simpliﬁ- cations: (i) Considering Kitaev’s approach (see Fig. 1), the in- put state|1⟩ (in decimal representation) is subject to a conditional multiplication based on the most-signiﬁcant bit k of the period register. At most there will be two results after this ﬁrst step. It follows that, for the very ﬁrst step it is suﬃcient to implement an optimized oper- ation that conditionally maps|1⟩→| a2k mod N⟩. Con- sidering the importance of a high-ﬁdelity multiplication (with its performance being fed-forward to all subsequent qubits), this eﬃcient simpliﬁcation improves the overall performance of experimental realizations. (ii) Subsequent multipliers can similarly be replaced with maps by considering only possible outputs of the previous multiplications. However, using such maps will become exponentially more challenging, as the number of input and output states to be considered grows exponen- tially with the number of steps: after n steps, 2n > N possible outcomes need to be considered - a numerical task as challenging as factoring N by classical means. Thus, controlled full modular multipliers need to be im- plemented. Fig. 2 shows the experimentally obtained truth table for the modular multiplier (2 mod 15) (see also supplementary material for modular multipliers with bases{7, 8, 11, 13}). These quantum circuits can be eﬃ- ciently derived from classical procedures using a variety of standard techniques for reversible quantum arithmetic and local logic optimization [15, 16]. 3 151413121110 Output 9876543210151413121110987 Input 6543210 0 0.7 0.6 0.5 0.4 0.3 0.2 0.1 151413121110 Output 9876543210151413121110987 Input 6543210 0.3 0.4 0.5 0.6 0 0.7 0.1 0.2 a) b) FIG. 2: Experimentally obtained truth table of the controlled 2 modular 15 multiplier: a) with the control-qubit being in state 0, the truth table corresponds to the identity operation; b) when the control qubit triggers the multiplication, the truth table illustrates the multiplication of the input state with 2 modular 15. (iii) The very last multiplier allows one more simpliﬁ- cation: Considering that the actual results of the modu- lar exponentiation are not required for Shor’s algorithm (as only the period encoded in the period-register is of interest), the last multiplier only has to create the cor- rect amount of correlations between the period register and the computation register. Local operations after the conditional (entangling) operations may be discarded to facilitate the ﬁnal multiplication without aﬀecting the re- sults of the implementation. (iv) In rare cases, certain qubits are not subject to operations in the computation. Thus, these qubits can be removed from the algorithm entirely. For larger scale quantum computation, optimization steps (i), (iii) and (iv) will only marginally eﬀect the performance of the implementation. They represent only a small subset of the entire computation which mainly consists of the full modular multipliers. Thus, the real- ization of these modular multipliers is a core requirement for scalable implementations of Shor’s algorithm. Furthermore, Kitaev’s approach requires in-sequence measurements, qubit-recycling to reset the measured qubit, feed-forward of gate settings based on previous measurement results, as well as numerous controlled quantum operations - tasks that have not been realized in a combined experiment so far. We demonstrate these techniques in our realization of Shor’s algorithm in an ion-trap quantum computer, with ﬁve 40Ca+ ions in a linear Paul trap. The qubit is encoded in the ground state S1/2(m =−1/2) = |1⟩ and the metastable state D5/2(m =−1/2) = |0⟩. The universal set of quantum gates consists of the entan- gling Mølmer-Sørenson interaction [17], collective op- erations of the form exp( −iθ 2Sφ) with Sφ = ∑ iσ(i) φ , σ(i) φ = cos(φ)σ(i) x + sin(φ)σ(i) y , σ(i) {x,y} the Pauli operators of qubit i, θ = Ωt determined by the Rabi frequency Ω and laser pulse duration t, φ determined by the relative phase between qubit and laser, and single qubit phase rotations induced by localized AC-Stark shifts (for more details see the supplementary material and Ref. 18). Uni- tary operations illustrated in Fig. 1 are decomposed into primitive components such as two-target C-NOT and C- SWAP gates (or gates with global symmetries such as the four-target C-NOT employed here), from which an adap- tation of the GRAPE algorithm [19] can eﬃciently derive an equivalent sequence of laser pulses acting on only the relevant qubits. The problem with this approach is that the resulting sequence generally includes operations act- ing on all qubits. Implementing the optimized 3-qubit operations on a 5-ion string therefore requires decoupling of the remaining qubits from the computation space. We spectroscopically decouple qubits by transferring any in- formation from |S⟩ → |D′⟩ = D5/2(m = −5/2) and |D⟩ → |S′⟩ = S1/2(m = 1 /2). Here, the subspace {|S′⟩,|D′⟩} serves as a readily available “quantum cache” to store and retrieve quantum information in order to fa- cilitate quantum computations. Finally, to complete the toolbox necessary for a Ki- taev’s approach to Shor’s algorithm, we also implement single qubit readout (by encoding all other qubits in the{|D⟩,|D′⟩} subspace and subsequent electron shelv- ing [20] on the S1/2 ↔ P1/2 transition), feed-forward (by storing counts detected during the single-qubit read- 4 out [21] in a classical register and subsequent condi- tional laser pulses) and state-reinitialization (using opti- cal pumping for the ion, and Raman-cooling [22, 23] for the motional state of the ion string). The pulse sequences and additional information on the implementation on the modular multipliers are available as supplementary ma- terial. The key diﬀerences of our implementation with respect to previous realizations of Shor’s algorithm are: a) the en- tire quantum register is employed, without sparing qubits that don’t partake in the calculation; b) besides the triv- ial ﬁrst multiplication step (corresponding to r = 2 for a ={4, 11, 14}, realized only once for a = 11), all non- trivial modular multipliers a = {2, 7, 8, 13} have been realized and applied; and c) Kitaev’s originally proposed scheme is implemented with complete qubit recycling – doing both readout and reinitialization on the very same physical qubit. This is especially important for factor- ing 15 with base {2,7,8,13}, as at least two steps are required for the semiclassical QFT. In our realization we go beyond the minimal implementation of Shor’s algo- rithm and not only employ all 7 qubits (comprised of 4 physical qubits in the computational register, 1 qubit in the periodicity register - recycled twice, plus additional cache qubits), but also include multiplication with up to the fourth power (although they correspond to the iden- tity operation). This represents a realistic attempt at a scalable implementation of Shor’s algorithm as the entire qubit register remains subject to decoherence processes along the computation, and no simpliﬁcations are em- ployed which presume prior knowledge of the solution. The measurement results for base a ={2, 7, 8, 11, 13} with periodicities r ={4, 4, 4, 2, 4} are shown in Fig. 3. In order to quantify the performance of the implementa- tion, previous realizations mainly focused on the squared statistical overlap (SSO) [24], the classical equivalent to the Uhlmann ﬁdelity [10]. While we achieved an SSO of{0.968(1), 0.964(1), 0.966(1), 0.901(1), 0.972(1) } for the case of a={2,7,8,11,13}, we argue that this does not answer the question of a user in front of the quantum computer: “What is the periodicity?” Shor’s algorithm allows one to deduce the periodicity with high probabil- ity from a single-shot measurement, since the output of the QFT is, in the exact case, a ratio of integers, where the denominator gives the desired periodicity. This peri- odicity is extracted using a continued fraction expansion, applied to x/2k, a good approximation of the ideal case when k, the number of qubits, is suﬃciently large. For the realised examples, the probabilistic nature of Shor’s algorithm becomes clear: the output state 0 never yields any information. For periodicity 4 (and 3 qubits in the period-register), the output state 4 suggests a fraction 4 23 = 1 2, thus a periodicity of 2 and also fails. For peri- docity 4, only the output states 2 and 6 allow one to de- duce the correct periodicity. In our realisations to bases a ={2, 7, 8, 11, 13}, the probabilities to obtain output 0 1 2 3 4 5 6 7 0.0 0.2 0.4 0.6 0.8 1.0 1.2 Output state rel. probability Shor: 15 base 2 SSO = 0.97 0 1 2 3 4 5 6 7 Shor: 15 base 7 SSO = 0.96 0 1 2 3 4 5 6 7 Shor: 15 base 8 SSO = 0.97 0 1 2 3 4 5 6 7 Shor: 15 base 11 SSO = 0.90 0 1 2 3 4 5 6 7 Shor: 15 base 13 SSO = 0.97 QFT output state FIG. 3: Results and correct order-assign probability for the diﬀerent implementations to factor 15: a) 3-digit results (in decimal representation) of Shor’s algorithm for the diﬀerent bases. The ideal data (red) for periodicity {2, 4} is superim- posed on the raw data (blue). The squared statistical overlap is larger than 90% for all cases. states that allow the derivation of the correct periodic- ity are{56(2), 51(2), 54(2), 47(2), 50(2)}%. Thus, a con- ﬁdence that the correct periodicity is obtained at a level of more than 99%, requires the experiment to run about 8 times. In summary, we have presented the realization of Ki- taev’s vision to realize a scalable Shor’s algorithm with 3-digit resolution to factor 15 using bases {2,7,8,11,13}. Here, a semiclassical QFT combined with single-qubit readout, feed-forward and qubit recycling was success- fully employed. Compared to the traditional algorithm, the required number of qubits can thus be reduced by almost a factor of 3. Furthermore, the entire quantum register has been subject to the computation in a “black- box” fashion. Employing the equivalent of a quantum cache by spectroscopic decoupling signiﬁcantly facilitated the derivation of the necessary pulse sequences to achieve high-ﬁdelity results. In the future, spectroscopic decou- pling might be replaced by physically moving the qubits from the computational zone using segmented traps [25]. Our investigations also reveal some open questions and problems for current and upcoming realizations of Shor’s algorithm, which also apply to several