FILE: 1805.08873v1.pdf
PAGES: 50
TITLE_GUESS: Rigorous Analysis of a Randomised Number Field Sieve
ABSTRACT_EXTRACT:
[not found]
FIRST_PAGES_TEXT:
arXiv:1805.08873v1 [math.NT] 22 May 2018 Rigorous Analysis of a Randomised Number Field Sieve Jonathan D. Lee a, Ramarathnam Venkatesan b aMathematical Institute, University of Oxford, UK & Microso ft Research Redmond bMicrosoft Research India & Redmond Abstract Factorisation of integers n is of number theoretic and cryptographic signiﬁcance. The Number Field Sieve (NFS) introduced circa 1990, is still the state of the art algorithm, but no rigorous proof that it halts or generates relationships is known. We propose and analyse an exp licitly randomised variant. For each n, we show that these randomised variants of the NFS and Coppersm ith’s multiple polynomial sieve ﬁnd congruences of squares in expected times matching the best-kno wn heuristic estimates. Keywords: Factoring, Probabilistic Combinatorics, Additive Number Theory 2010 MSC: 11Y05 (primary); 11-04, 05D40, 60C05 (secondary) Contents 1 Introduction 1 2 Our Results 5 3 Preliminaries 6 4 The Randomised Number Field Sieve 13 5 Finding Many Relationships and the Proof of Theorem 2.5 15 6 Controlling Algebraic Obstructions to Squares and the Pro of of Theorem 2.6 25 7 Non-trivial F actors from F ound Congruences 38 8 Smooth Numbers in Progressions and the Proof of Lemma 5.21. 39 1. Introduction For real numbers a,b,x , we write Lx(a,b ) = exp ( b(logx)a(log logx)1− a ) . To factor n, modern factoring algorithms ﬁrst ﬁnd a congruence of squares x2 = y2 mod (n), which is hopefully not trivial in the sense x̸=±y mod (n), and next compute gcd( x± y,n ) to obtain factors of n. Hence the runtime analysis is devoted to the ﬁrst part and studied a ctively [6, 48, 10, 4, 47, 11, 58, 33, 49], Email addresses: jonathan.lee@merton.ox.ac.uk, jonatlee@microsoft.com (Jonathan D. Lee), venkie@microsoft.com (Ramarathnam Venkatesan) Preprint submitted to Elsevier June 27, 2017 while the second part has been elusive and heuristic with the exceptio n of variants of Dixons algorithm and the class group algorithm. In the subsequent, we introduce a rand omised variant of the Number Field Sieve and provide an unconditional analysis on the ﬁrst part, and provide evidence that the factors so obtained are non-trivial. In particular: Theorems 2.1 (p. 5) and 2.3 (p. 5). There is a randomised variant of the Number Field Sieve which for eachn ﬁnds congruences of squares x2 =y2 mod (n) in expected time: Ln ( 1 3, 3 √ 64 9 + o(1) ) ≃ Ln (1 3, 1. 92299... + o(1) ) . These congruences of squares are not trivially of the form x =±y: conditional on a mild character assump- tion (Conjecture 7.1 (p. 39)), for n the product of two primes congruent to 3 mod 4, the factors of n may be recovered in the same asymptotic run time. We use a probabilistic technique, which we term stochastic deepening, to avoid the need to show second moment bounds on the distribution of smooth numbers. These resu lts can be shown to extend to Copper- smith’s multiple polynomial sieve of [9], a randomised variant of which ﬁnd s congruences of squares modulo n in expected time: Ln   1 3, 3 √ 92 + 26 √ 13 27 + o(1)   ≃ Ln (1 3, 1. 90188... + o(1) ) . Part of the randomisation is similar to the polynomial selection algorith m of Kleinjung [26], which is popular in empirical studies, in that we add an ( X− m)R(X) to the ﬁeld polynomial where m is the root of that polynomial in Z/n Z. Kleinjung chooses m and R to minimise certain norms and improve smoothness, whilst our R is random. Integer factorisation is of fundamental importance both in algorit hmic number theory and in cryptog- raphy. In the latter setting, it is especially important to have eﬀect ive bounds on the run time of existing algorithms, as many existing systems depend on being able to produc e integers whose factorisations will remain unknown for decades, even allowing for the rapid increases in the cost-eﬀectiveness of computational hardware. For example, an understanding of the factoring of num bers n with log 2n≈ 4096 is important in practice, while the public record for a factorisation of a general nu mber stands at log 2n≈ 768. A uniform and eﬀective bound will be useful in understanding the run time as log 2n increases. While our methods apply to general composites, in applications there is particular inter est in factoring semiprimes, integers with two prime factors of nearly equal size, which are considered to be the most challenging type of integer to factor. The Number Field Sieve (NFS) has been the state of the art algorithm for factorisation since its intro- duction nearly three decades ago [6]. Unfortunately, its analysis h as been thus far entirely heuristic [49], with the claimed run time on an input n ofLn ( 1 3, 3 √ 64 9 + o(1) ) . This became of practical importance in the mid 1990s when it bettered the (also heuristic) Ln (1 2, 1 + o(1) ) run time of the previous champion Quadratic Sieve. It is a priori unclear how to argue that the NFS even halts [35]. Even a ssuming standard conjectures (e.g.; GRH), there is no analysis that any substantial part of the NF S will halt. In particular, the NFS and other algorithms critically depend on the existence of suﬃcient numb ers of smooth elements among rational or algebraic integers on certain linear forms, which cannot be guara nteed in current algorithms. Similarly, in implementations the NFS cannot assure the reduction from smoot h relations to a congruence of squares, because ideal factorisation is avoided in favour of Adleman’s approa ch based on characters. Our explicit randomisation allows us to get around these problems by analysing th e average case as opposed to the worst case, inﬂuenced by the recent works on distribution of smooths on arithmetic progressions [53, 14, 15, 17] and the philosophy that sums of arithmetic functions are essentially det ermined by the part over smooths [16, 60]. 2 In short, we make essential use and strengthening of these tools as well as probabilistic combinatorics, and it may explain why no analysis was available earlier. The fastest algorithms with known rigorous analysis are unfortuna tely much slower, with the best result being Ln (1 2, 1 + o(1) ) [33], where the basic operations are performed in the class group on quadratic forms; they also show that hazarding new conjectures that seem necess ary to formally analyse run times can be risky, as they may formally contradict earlier natural conjecture s. In this paper, we will present and analyse an explicitly randomised version of the NFS. We will show bounds on the expectation of the time taken to produce congruences of squares (x,y ) : x2≡ y2 mod (n). These bounds will be of form Ln (1 3, Θ(1) ) , and are the ﬁrst time that bounds of this type have been obtained f or any factorisation algorithm. To obtain sharper estimates for the Θ(1) term, we use randomness to remo ve dependence on second moment bounds for which proofs known to us use the Riemann Hypothesis. This is ana logous to the situation between the Miller and Miller-Rabin primality tests. Historically, there has been a close link in the sieving aspects of intege r factorisation and the discrete logarithm problems. The NFS, along with many other factorisation alg orithms, has an identically named analogue for computing discrete logarithms. For the discrete logar ithm in small characteristic, recent break- through results [24, 5] have suggested that much faster algorith ms exist. We will not touch on an analysis of this algorithm for the discrete logarithm in this paper. We provide a conditional analysis of whether the congruences of sq uares will be fruitful, that is whether they yield a non-trivial factorisation of n. In the speciﬁc case that n = pq is semiprime with p≡ q≡ 3 mod (4), and modulo a character decorrelation conjecture, we ar e able to show that the factors are non-trivial with probability 1 / 2. As the conjecture may indicate, the analysis of this fruitfulness seems involved and likely to require methods that are substantially diﬀerent from the init ial analysis of relationship formation. For example, the analysis of Pollard’s Rho algorithm for the discrete lo garithm, the run time for forming relationships was shown to be √ p log3p [38] using characters and quadratic forms; this was later improved to be optimal up to constant factors by Kim, Montenegro, Peres and Tetali [25] using combinatorial methods. However, the known proof that the relations are fruitful [37] still uses analytic methods with a substantially more complex analysis. For the Number Field Sieve we expect that the analysis will be even more arduous. 1.1. Combinations of Congruences All modern factoring algorithms have core similarities, and are refer red to as combinations of congruences algorithms to draw attention to this fact. To present the main ideas involved, we will discuss Dixon’s random squares algorithm. The ﬁrst observation, due to Fermat, is that x2≡ y2 mod (n)⇔ n|x2− y2 = (x +y)(x− y) and if we are lucky we may ﬁnd that n does not divide x± y; in this case gcd( n,x +y) is a non-trivial factor of n. We can generate pairs (xi,z i) : x2 i≡ zi mod (n), by choosing xi at random to be an integer in [ n] and setting zi = x2 i mod (n). Then to produce a pair (x,y ) it suﬃces to ﬁnd a subset S of the zi whose product is a square in Z. We note that even the problem of ﬁnding how large a random subset of [ n] must be to contain a subset S whose product is a square is of substantial independent interest [48, 10]. The main step is to searc h for B-smooth zi: zi :p prime,p|zi⇒ p<B ⇔ zi = ∏ pj <B pei,j j , p j prime. 3 If all the zi are B-smooth then a product zsi i is square if and only if ∀j, 2| ∑ i siei,j ⇔ s∈ kerF2(E) where E = (ei,j ) and s is a column vector of si, which can be found by standard means whenever it exists. This calculation with indices ei,j is what gives this class of algorithm its name. Once a relationship x2≡ y2 mod (n) has been found, we compute gcd( x± y,n ) and hope that at least one is a non-trivial factor of n; in this case we say that the congruence is fruitful. Hence to have a functional algorithm it suﬃces to have methods for ﬁnding B-smooth values of the zi. Analysis of the run time additionally requires some estimate of the pr obability that zi is B-smooth. At a high-level, we can see that as B is increased, the density of B-smooth integers increases, whilst the number of B-smooth zi we will need to ﬁnd to guarantee that a vector si exists will also increase. These two eﬀects are balanced when B =Ln (1 2, Θ(1) ) . For Dixon’s algorithm, this choice results in a run time of Ln (1 2, 2 √ 2 + o(1) ) (see Corollary 3.12 (p. 8) with b = 1 and a = 1 2 ). Various modiﬁcations of this core algorithm exist. One line of modiﬁcat ions is to keep track of zi which are almost B-smooth, in the sense of having few factors which are too large, ho ping to combine them later to ﬁnd B-smooth numbers lying under a square in Z [31]. Another approach is to attempt to make the numberszi smaller, since heuristically the density of B-smooth numbers is decreasing in |zi|. This is the core idea in Vall´ ee’s algorithm [58], which can be rigorously shown to have a r un time of Ln ( 1 2, √ 4/ 3 + o(1) ) . The Quadratic Sieve reduces the size of the zi to be n 1 2 +o(1) by choosing xi≃ √ n, and achieves a heuristic run time of Ln (1 2, 1 + o(1) ) , though its analysis seems out of reach. Observe that in all of these algorithms, we use combinations of cong ruences to ﬁnd a product of the zi which is a square y2, but ensure that the associated product of x2 i is a square by ensuring that each relation x2 i≡ zi mod (n) has a square on the left-hand side. Further gains are made by rela xing this condition, so that we ﬁnd both x and y as a result of combining congruences. For example, the Schorr-Se ysen-Lenstra algorithm [33] shifts its attention from square integers to quadrat ic forms with one coeﬃcient smooth and of discriminant−dn for small values of d, and is able to achieve an expected run time of Ln (1 2, 1 + o(1) ) . 1.2. The Number Field Sieve In the NFS, we instead observe that there are rings other than Z lying over Z/n Z. In particular, if we are given a monic polynomial f with a root modulo n at some integer m, we can form the following commuting diagram: Z[X] Z[X]/ (f )Z Z/n Z ◦ mod (f )x → m X → m, mod (n)mod (n) If f is reducible, we may directly extract factors of n, and so we may assume f is irreducible. We can identify values of Z/n Z which are squares mod n either by virtue of each of them lying under a square in Z or a square in Z[X]/ (f ). The second ring is then a subset of the ring of integers of the num ber ﬁeld Q[X]/ (f ); on the ring of integers we have a notion of divisibility into prime ideals , a notion of size via the ﬁeld norm , and thus we can deﬁne a natural analogue of B-smoothness. In the NFS, we choose linear polynomials in Z[X] with coeﬃcients of size at most Ln (1 3, O(1) ) , and project them into both Z and Z[X]/ (f ). We then hope to ﬁnd many polynomials such that both projections are B-smooth. Then we use linear algebra to ﬁnd a subset whose product is square in Z and also square 4