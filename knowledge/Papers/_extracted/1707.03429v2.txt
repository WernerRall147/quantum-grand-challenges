FILE: 1707.03429v2.pdf
PAGES: 24
TITLE_GUESS: Open Quantum Assembly Language
ABSTRACT_EXTRACT:
[not found]
FIRST_PAGES_TEXT:
Open Quantum Assembly Language Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta January 10th, 2017 1 Background Software architectures, compilers, and languages speciﬁcally for quantum computing have been studied by the academic community for more than a decade ([1–4] and references therein). Researchers have implemented software and simulators that can be used in practice to study quantum algorithms at many scales. While we cannot survey this work here, we list a few of these projects, several of which include software that has been made readily available: Liquid [5, 6], Scaﬀold [7, 8], Quipper [9–11], ProjectQ [12, 13], QCL [14, 15], Quiddpro [16, 17], Chisel-q [18, 19], and Quil [20, 21]. Our goal in this document is to describe an interface language for the Quantum Expe- rience that enables experiments with small depth quantum circuits. The language can be generated by the Composer, hand-written, or targeted by higher level software tools, such as those above. Before we do so, we discuss quantum programs in general to provide con- text. General quantum programs require coordination of quantum and classical parts of the computation. One way to think about general quantum programs is to identify their distinct phases of execution [11]. Fig. 1 shows a high-level diagram of the processes and abstractions involved in specifying a quantum algorithm, transforming the algorithm into executable form, running an experiment or simulation, and analyzing the results. A key idea throughout these processes is the use of intermediate representations. An intermediate rep- resentation (IR) of a computation is neither its source language description, nor the target machine instructions, but something in between. Compilers may use several IRs during the process of translating and optimizing a program. Compilation. This phase takes place on a classical computer in a setting where speciﬁc problem parameters are not yet known and no interaction with the quantum computer is required, i.e. it is oﬄine. The input is source code describing a quantum algorithm and any compile time parameters. The output is a combined quantum/classical program expressed using a high level IR. During this phase, it is possible to compile classical procedures into object code and make initial passes that do not require complete knowledge of the problem parameters. Circuit generation. This takes place on a classical computer in an environment where speciﬁc problem parameters are now known, and some interaction with the quantum com- puter may occur, i.e. this is an online phase. The input is a quantum/classical program expressed using a high level IR, as well as all remaining problem parameters. The output 1 arXiv:1707.03429v2 [quant-ph] 13 Jul 2017 is a collection of quantum circuits, or quantum basic blocks, together with associated clas- sical control instructions and classical object code needed at run-time. A basic block is a straight-line code sequence with no branches (except at the entry and exit points). Since feedback can occur on multiple time scales, the quantum circuits may include instructions for fast feedback. Other classical control instructions outside of the quantum circuit basic block include, for example, run-time parameter computations and measurement-dependent branches. External classical object code could include algorithms to process measurement outcomes into control ﬂow conditions or results, or to generate new basic blocks on the ﬂy. The output of circuit generation is expressed using a quantum circuit IR. Further circuit generation may occur based on processed measurement results. Execution. This takes place on physical quantum computer controllers in a real-time environment, i.e. the quantum computer is active. The input is a collection of quantum circuits and associated run-time control statements expressed using a quantum circuit IR. The input is processed by a high-level controller into a stream of real-time instructions in a low-level format that corresponds to physical operations. These are executed on a low-level controller, and a corresponding results stream provides measurement data back to the high-level controller when needed. In general, the high level controller (or virtual machine) can execute classical control instructions and external object code. The output of circuit execution is a collection of processed measurement results returned from the high-level controller. Post-processing. This takes place on a classical computer after all real-time processing is complete. The input is a collection of processed measurement results, and the output is intermediate results for further circuit generation and/or the ﬁnal result of the quantum computation. Quantum algorithm Quantum circuit(s) (+ classical control) System controlRstream System independent transformations System dependent transformations HighRlevel compilationRand optimization SimulationR/ ExperimentR ControllerR:low2 Requested results Analysis SimulationR/ ExperimentR ControllerR:high2 scheduleRandR issue :real4time2 useRspecificRproblemRparameters Quantum PRclassical program parallelRexecution :real4time2 PhaseR1:RcompileRtime PhaseR2:RcircuitRgeneration PhaseR3:RcircuitRexecution RawRsystem resultRstream SystemRstate Algorithm output :offline2 APIRP Resource Manager :online2 PhaseR4:Rpost4processing :online2 :online2 passRto/from selectedRbackends Processed results Validated quantum circuit(s) (+ classical control) Analysis :offline2 interactRwithRbackends circuit generation Figure 1: Block diagrams of processes (blue) and abstractions (red) to transform and execute a quantum algorithm. The emphasized quantum circuit abstraction is the main focus of this document. The API and Resource Manager (green) represents the gateway to backend processes for circuit execution. Dashed vertical lines separate oﬄine, online, and real-time processes. 2 Our model of program execution on the Quantum Experience does not allow fully general classical computations in the loop with quantum computations, as described above, because qubits remain coherent for a limited time. Quantum programs are broken into distinct circuits whose quantum outputs cannot be carried over into the next circuit. Classical computation is done between quantum circuit executions. Users actively participate in the circuit generation phase and manually implement part of feedback path through the high level controller in Fig. 1, observing outcomes from the previous quantum circuit and choosing the next quantum circuit to execute. Making use of an API to the execution phase, users can write their own software for compilation and circuit generation that interacts with the hardware over a sequence of quantum circuit executions. After obtaining all of the processed results, users may post-process the data oﬄine. We specify part of a quantum circuit intermediate representation based on the quantum circuit model, a standard formalism for quantum computation [22]. The quantum circuit abstraction is emphasized in Fig. 1. The IR expresses quantum circuits with fast feedback, such as might constitute the basic blocks of a full-featured IR. A basic block is a straight-line code sequence with no branches (except at the entry and exit points). We have chosen to include statements that are essential for near-term experiments and that we believe will be present in any future IR. The representation will be quite familiar to experts. The human-readable form of our quantum circuit IR is based on “quantum assembly language” [3, 23–26] or QASM (pronounced kazm). QASM is a simple text language that describes generic quantum circuits. QASM can represent a completely unrolled quantum program whose parameters have all been speciﬁed. Most QASM variants assume a discrete set of quantum gates, but our IR is designed to control a physical system with a parameterized gate set. While we use the term “quantum assembly language”, this is merely an analogy and should not be taken too far. Open QASM represents universal physical circuits, so we propose a built-in gate basis of arbitrary single-qubit gates and a two-qubit entangling gate (CNOT) [27]. We choose a simple language without higher level programming primitives. We deﬁne diﬀerent gate sets using a subroutine-like mechanism that hierarchically speciﬁes new unitary gates in terms of built-in gates and previously deﬁned gate subroutines. In this way, the built-in basis is used to deﬁne hardware-supported operations via standard header ﬁles. The subroutine mechanism allows limited code reuse by hierarchically deﬁning more complex operations [7, 26]. We also add instructions that model a quantum-classical interface, speciﬁcally measurement, state reset, and the most elemental classical feedback. The remaining sections of this document specify Open QASM and provide examples. 2 Language The syntax of the human-readable form of Open QASM has elements of C and assembly languages. The ﬁrst (non-comment) line of an Open QASM program must be OPENQASM M.m; indicating a major version M and minor version m. Version 2.0 is described in this document. The version keyword cannot occur multiple times in a ﬁle. Statements are separated by semicolons. Whitespace is ignored. The language is case sensitive. Comments begin with a pair of forward slashes and end with a new line. The statement include 3 q[0] q[1] r[0] r[1] CX q[0],r[0]; q[0] q[1] r[0] r[1] CX q,r; q[0] q[1] r[0] r[1] CX q,r[0]; q[0] q[1] r[0] r[1] CX q[0],r; Figure 2: The built-in two-qubit entangling gate is the controlled-NOT gate. If a and b are qubits, the statement CX a,b; applies a controlled-NOT (CNOT) gate that ﬂips the target qubit b iﬀ the control qubit a is one. If a and b are quantum registers, the statement applies CNOT gates between corresponding qubits of each register. There is a similar meaning when a is a qubit and b is a quantum register and vice versa. q[0] U(θ,φ,λ) q[0]; U(θ,φ,λ) q[0] q[1] U(θ,φ,λ) q; U(θ,φ,λ) U(θ,φ,λ) Figure 3: The single-qubit unitary gates are built in. These gates are parameterized by three real parameters θ, φ, and λ. If the argument q is a quantum register, the statement applies size(q) gates in parallel to the qubits of the register. "filename"; continues parsing filename as if the contents of the ﬁle were pasted at the location of the include statement. The path is speciﬁed relative to the current working directory. The only storage types of Open QASM (version 2.0) are classical and quantum registers, which are one-dimensional arrays of bits and qubits, respectively. The statement qreg name[size]; declares an array of qubits (quantum register) with the given name and size. Identiﬁers, such as name, must start with a lowercase letter and can contain alpha-numeric characters and underscores. The label name[j] refers to a qubit of this register, where j ∈ {0, 1,..., size(name)−1}. The qubits are initialized to |0⟩. Likewise, creg name[size]; declares an array of bits (register) with the given name and size. The label name[j] refers to a bit of this register, where j ∈ {0, 1,..., size(name) − 1}. The bits are initialized to 0. The built-in universal gate basis is “CNOT + U(2)”. There is one built-in two-qubit gate (Fig. 2) CNOT :=   1 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0   (1) called the controlled-NOT gate. The statement CX a,b; applies a CNOT gate that ﬂips the target qubit b if and only if the control qubit a is one. The arguments cannot refer to the same qubit. Built-in gates have reserved uppercase keywords. If a and b are quantum registers with the same size , the statement means apply CX a[j], b[j]; for each index j 4